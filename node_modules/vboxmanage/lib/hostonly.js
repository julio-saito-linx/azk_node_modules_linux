// Generated by CoffeeScript 1.6.3
(function() {
  var async, command, parse, proto,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  async = require('async');

  parse = require('./parse');

  proto = require('./proto');

  command = require('./command');

  /*
  	* Lists hostonly network interfaces.
  	*
  	* @param {function(?err, result)} callback
  */


  exports.list = function(callback) {
    return command.exec('list', 'hostonlyifs', function(err, code, output) {
      if (err) {
        return callback(err);
      }
      if (code > 0) {
        return callback(new Error("cannot list hostonly ifs"));
      }
      if (callback) {
        return callback(null, parse.linebreak_list(output));
      }
    });
  };

  /*
  	* Creates hostonly interfaces.
  	*
  	* @param {function(?err)} callback
  */


  exports.create_if = function(callback) {
    return command.exec('hostonlyif', 'create', function(err, code, output) {
      if (err) {
        return callback(err);
      }
      if (code > 0) {
        return callback(new Error("cannot create hostonly interface"));
      }
      if (callback) {
        return callback();
      }
    });
  };

  /*
  	* Removes hostonly interfaces.
  	*
  	* @param {function(?err)} callback
  */


  exports.remove_if = function(netname, callback) {
    return command.exec('hostonlyif', 'remove', netname, function(err, code, output) {
      if (err) {
        return callback(err);
      }
      if (code > 0) {
        return callback(new Error("cannot remove hostonly interface " + netname));
      }
      if (callback) {
        return callback();
      }
    });
  };

  /*
  	* Configures hostonly interfaces.
  	*
  	* @param {string} netname
  	* @param {string} ip
  	* @param {string} netmask
  	* @param {function(?err)} callback
  */


  exports.configure_if = function(netname, ip, netmask, callback) {
    return command.exec('hostonlyif', 'ipconfig', netname, '--ip', ip, '--netmask', netmask, function(err, code, output) {
      if (err) {
        return callback(err);
      }
      if (code > 0) {
        return callback(new Error("cannot configure hostonly interface " + netname));
      }
      if (callback) {
        return callback();
      }
    });
  };

  /*
  	* Ensure hostonly interface.
  	*
  	* @param {string} netname
  	* @param {string} ip
  	* @param {string} netmask
  	* @param {function(?err)} callback
  */


  exports.ensure_if = function(netname, ip, netmask, callback) {
    var snapshoted_ifs;
    snapshoted_ifs = null;
    return exports.list(function(err, ifaces) {
      var callee, created_ifs, iface, wrapper;
      if (err) {
        return callback(err);
      }
      if (!snapshoted_ifs) {
        snapshoted_ifs = ifaces.map(function(iface) {
          return iface.Name;
        });
      }
      iface = ifaces.narrow(function(previous, current) {
        if (previous && previous.Name === netname) {
          return previous;
        }
        if (current && current.Name === netname) {
          return current;
        }
      });
      if (!iface) {
        callee = arguments.callee;
        return exports.create_if(function(err) {
          if (err) {
            return callback(err);
          }
          return exports.list(callee);
        });
      } else {
        created_ifs = ifaces.map(function(iface) {
          return iface.Name;
        });
        created_ifs = created_ifs.filter(function(iface) {
          return __indexOf.call(snapshoted_ifs, iface) < 0 && iface !== netname;
        });
        if (created_ifs.length > 0) {
          wrapper = function(next) {
            return async.each(created_ifs, (function(iface, callback) {
              return exports.remove_if(iface, callback);
            }), next);
          };
        } else {
          wrapper = function(next) {
            if (next) {
              return next();
            }
          };
        }
        if (iface.IP !== ip || iface.NetworkMask !== netmask) {
          return wrapper(function(err) {
            if (err) {
              return callback(err);
            }
            return exports.configure_if(netname, ip, netmask, callback);
          });
        } else {
          return wrapper(function(err) {
            if (err) {
              return callback(err);
            }
            if (callback) {
              return callback();
            }
          });
        }
      }
    });
  };

}).call(this);
