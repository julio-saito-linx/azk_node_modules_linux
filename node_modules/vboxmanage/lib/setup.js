// Generated by CoffeeScript 1.6.3
(function() {
  var adaptors, async, dhcp, hostonly, proto, share;

  async = require('async');

  dhcp = require('./dhcp');

  proto = require('./proto');

  share = require('./share');

  hostonly = require('./hostonly');

  adaptors = require('./adaptors');

  /*
  	* Configures the system.
  	*
  	* @param {config}
  	* @param {function(?err)} callback
  */


  exports.system = function(config, callback) {
    var actions, c, netconfig, netname, _base, _base1, _ref, _ref1;
    actions = [];
    if (config.network == null) {
      config.network = {};
    }
    if ((_base = config.network).hostonly == null) {
      _base.hostonly = {};
    }
    if ((_base1 = config.network).internal == null) {
      _base1.internal = {};
    }
    _ref = config.network.hostonly;
    for (netname in _ref) {
      netconfig = _ref[netname];
      if (netconfig.ip == null) {
        return callback(new Error("no ip specified for hostonly network " + netname));
      }
      if (netconfig.netmask == null) {
        return callback(new Error("no netmask specified for hostonly network " + netname));
      }
      actions.push((function(netname, netconfig) {
        return function(callback) {
          return hostonly.ensure_if(netname, netconfig.ip, netconfig.netmask, callback);
        };
      })(netname, netconfig));
      if (netconfig.dhcp != null) {
        if (netconfig.dhcp.lower_ip == null) {
          return callback(new Error("no lower_ip specified for hostonly network " + netname + " dhcp"));
        }
        if (netconfig.dhcp.upper_ip == null) {
          return callback(new Error("no upper_ip specified for hostonly network " + netname + " dhcp"));
        }
        actions.push((function(netname, netconfig) {
          return function(callback) {
            return dhcp.ensure_hostonly_server(netname, netconfig.ip, netconfig.netmask, netconfig.dhcp.lower_ip, netconfig.dhcp.upper_ip, callback);
          };
        })(netname, netconfig));
        actions.push((function(netname, netconfig) {
          return function(callback) {
            return dhcp.enable_hostonly_server(netname, callback);
          };
        })(netname, netconfig));
      }
    }
    _ref1 = config.network.internal;
    for (netname in _ref1) {
      c = _ref1[netname];
      if (netconfig.ip == null) {
        return callback(new Error("no ip specified for internal network " + netname));
      }
      if (netconfig.netmask == null) {
        return callback(new Error("no netmask specified for internal network " + netname));
      }
      if (netconfig.dhcp != null) {
        if (netconfig.dhcp.lower_ip == null) {
          return callback(new Error("no lower_ip specified for internal network " + netname + " dhcp"));
        }
        if (netconfig.dhcp.upper_ip == null) {
          return callback(new Error("no upper_ip specified for internal network " + netname + " dhcp"));
        }
        actions.push((function(netname, netconfig) {
          return function(callback) {
            return dhcp.ensure_internal_server(netname, netconfig.ip, netconfig.netmask, netconfig.dhcp.lower_ip, netconfig.dhcp.upper_ip, callback);
          };
        })(netname, netconfig));
        actions.push((function(netname, netconfig) {
          return function(callback) {
            return dhcp.enable_internal_server(netname, callback);
          };
        })(netname, netconfig));
      }
    }
    if (actions.length === 0) {
      if (callback) {
        return callback();
      }
    } else {
      return async.series(actions, function(err) {
        if (err) {
          return err;
        }
        if (callback) {
          return callback();
        }
      });
    }
  };

  /*
  	* Configures a vm.
  	*
  	* @param {string} vm
  	* @param {object} config
  	* @param {function(?err)} callback
  */


  exports.machine = function(vm, config, callback) {
    var actions, adaptor, i, index, name, path, _base, _i, _len, _ref, _ref1;
    actions = [];
    if (config.network == null) {
      config.network = {};
    }
    if ((_base = config.network).adaptors == null) {
      _base.adaptors = [];
    }
    if (config.shares == null) {
      config.shares = {};
    }
    _ref = config.network.adaptors;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      adaptor = _ref[i];
      if (adaptor.type == null) {
        return callback(new Error("no type specified for adaptor"));
      }
      index = i + 1;
      switch (adaptor.type) {
        case 'hostonly':
          if (adaptor.network == null) {
            return callback(new Error("no network specified for adaptor"));
          }
          actions.push((function(vm, adaptor, index) {
            return function(callback) {
              return adaptors.set_hostonly(vm, index, adaptor.network, callback);
            };
          })(vm, adaptor, index));
          break;
        case 'internal':
          if (adaptor.network == null) {
            return callback(new Error("no network specified for adaptor"));
          }
          actions.push((function(vm, adaptor, index) {
            return function(callback) {
              return adaptors.set_internal(vm, index, adaptor.network, callback);
            };
          })(vm, adaptor, index));
          break;
        case 'nat':
          actions.push((function(vm, adaptor, index) {
            return function(callback) {
              return adaptors.set_nat(vm, index, callback);
            };
          })(vm, adaptor, index));
      }
    }
    _ref1 = config.shares;
    for (name in _ref1) {
      path = _ref1[name];
      actions.push((function(vm, name, path) {
        return function(callback) {
          return share.add_machine_folder(vm, name, path, false, false, callback);
        };
      })(vm, name, path));
    }
    if (actions.length === 0) {
      if (callback) {
        return callback();
      }
    } else {
      return async.series(actions, function(err) {
        if (err) {
          return err;
        }
        if (callback) {
          return callback();
        }
      });
    }
  };

}).call(this);
