{
  "name": "hipache",
  "version": "0.4.0",
  "description": "Complete high-scaled reverse-proxy solution",
  "keywords": [
    "reverse",
    "proxy",
    "http",
    "http-proxy"
  ],
  "homepage": "https://github.com/dotcloud/hipache",
  "bugs": {
    "url": "https://github.com/dotcloud/hipache/issues",
    "email": "sam.alba@gmail.com"
  },
  "license": "MIT",
  "main": "./bin/hipache",
  "bin": {
    "hipache": "./bin/hipache"
  },
  "directories": {
    "lib": "./lib"
  },
  "dependencies": {
    "http-proxy": "1.0.2",
    "redis": "0.10.x",
    "lru-cache": "2.5.x",
    "minimist": "0.0.8"
  },
  "devDependencies": {
    "mocha": "1.x",
    "jshint": "2.x",
    "gulp": "^3.5.5",
    "gulp-mocha": "^0.4.1",
    "gulp-eslint": "^0.1.5",
    "gulp-jshint": "^1.5.0",
    "jshint-stylish": "^0.1.5",
    "gulp-util": "^2.2.14",
    "chai": "^1.9.0",
    "istanbul": "^0.2.6",
    "npmlog": "^0.0.6",
    "memcached": "^0.2.8",
    "node-etcd": "^2.0.10",
    "ws": "^0.4.31",
    "coveralls": "^2.10.0",
    "connect": "^2.14.3"
  },
  "scripts": {
    "start": "./bin/hipache",
    "test": "istanbul test _mocha --report html -- test/**/*.js --reporter spec",
    "coveralls": "istanbul cover _mocha --report lcovonly -- test/**/*.js -R spec && cat ./coverage/lcov.info | coveralls && rm -rf ./coverage",
    "hint": "gulp hint"
  },
  "engines": {
    "node": ">=0.10.0",
    "npm": ">=1.0.0"
  },
  "engineStrict": true,
  "author": {
    "name": "Sam Alba",
    "email": "sam.alba@gmail.com",
    "url": "http://www.dotcloud.com/"
  },
  "maintainer": [
    "Sam Alba <sam.alba@gmail.com>",
    "Olivier Gambier <viapanda@gmail.com>"
  ],
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/dotcloud/hipache.git"
  },
  "contributors": [
    {
      "name": "Sam Alba",
      "email": "sam.alba@gmail.com"
    },
    {
      "name": "Olivier Gambier",
      "email": "viapanda@gmail.com"
    }
  ],
  "gitHead": "c32e3d2138590cbdb70a67e696c5f8252f7143dc",
  "readme": "Hipache: a distributed HTTP and websocket proxy\n===============================================\n\n[![NPM version][npm-image]][npm-url] [![Build Status][travis-image]][travis-url]  [![Dependency Status][depstat-image]][depstat-url] [![Coverage Status][coveralls-image]][coveralls-url] [![Code Climate][codeclimate-image]][codeclimate-url] [![Stories in Ready][waffle-image]][waffle-url]\n\nWARNING\n-----------\n\nThis is the documentation for `master`. If you are running Hipache release, you should look at the documentation on the `0.3` branch.\n\n\nWhat is it?\n-----------\n\nHipache (pronounce `hɪ'pætʃɪ`) is a distributed proxy designed to route high volumes of http and\nwebsocket traffic to unusually large numbers of virtual hosts, in a highly\ndynamic topology where backends are added and removed several times per second.\nIt is particularly well-suited for PaaS (platform-as-a-service) and other\nenvironments that are both business-critical and multi-tenant.\n\nHipache was originally developed at [dotCloud](http://www.dotcloud.com), a\npopular platform-as-a-service, to replace its first-generation routing layer\nbased on a heavily instrumented nginx deployment. It currently serves\nproduction traffic for tens of thousands of applications hosted on dotCloud.\nHipache is based on the node-http-proxy library.\n\n\nRun it!\n-------\n\n### 1. Installation\n\nFrom the shell:\n\n    $ npm install hipache -g\n\n*The '-g' option will make the 'hipache' bin-script available system-wide (usually linked from '/usr/local/bin')*\n\n\n### 2. Configuration (config.json)\n\nBasic Hipache configuration is described in a json file. For example:\n\n    {\n        \"server\": {\n            \"accessLog\": \"/var/log/hipache_access.log\",\n            \"workers\": 5,\n            \"maxSockets\": 100,\n            \"deadBackendTTL\": 30\n        },\n        \"http\": {\n            \"port\": 80,\n            \"bind\": [\"127.0.0.1\", \"::1\"]\n        },\n        \"https\": {\n            \"port\": 443,\n            \"bind\": [\"127.0.0.1\", \"::1\"],\n            \"key\": \"/etc/ssl/ssl.key\",\n            \"cert\": \"/etc/ssl/ssl.crt\"\n        },\n        \"driver\": \"redis://:password@127.0.0.1:6379/0\"\n    }\n\n * __server__: generic server settings, like accesslog location, or number of workers\n    * __server.accessLog__: location of the Access logs, the format is the same as\nnginx. Defaults to `/var/log/hipache/access.log` if not specified.\n    * __server.workers__: Number of workers to be spawned. You need to request to have at least 1 worker, as the\nmaster process does not serve any request. Defaults to `10` if not specified.\n    * __server.maxSockets__: The maximum number of sockets which can be opened on each backend (per worker). Defaults to `100` if not specified.\n    * __server.deadBackendTTL__: The number of seconds a backend is flagged as\n'dead' before retrying to proxy another request to it (doesn't apply if you are using a third-party health checker). Defaults to `30`.\n * __http__: specifies on which ips/ports hipache will listen for http traffic. By default, hipache listens only on 127.0.0.1:80\n    * __http.port__: port to listen to for http. Defaults to `80`.\n    * __http.bind__: IPv4 (or IPv6) address, or addresses to listen to. You can specify a single ip, an array of ips, or an array of objects `{address: IP, port: PORT}` if you want to use a specific port on a specific ip. Defaults to `127.0.0.1`.\n * __https__: specifies on which ips/ports hipache will listen for https traffic. By default, hipache doesn't listens for https traffic.\n    * __https.port__: port to listen to for https. Defaults to `443`.\n    * __https.key__: path to key file to use. No default.\n    * __https.passphrase__: optional passphrase for the key file.\n    * __https.cert__: path to certificate file to use. No default.\n    * __https.ca__: optional path to additional CA file to serve. Might be a string, or an array.\n    * __https.bind__: similarly to http.bind, you can specific a single ip, an array of ip, or an array of objects to override the port, key/cert/ca files on a per-ip basis.\n * __driver__: Redis url to connect to for dynamic vhost configurations. If you want a master/slave Redis, specify a second url for the master, eg: `driver: [\"redis://slave:port\", \"redis://master:port\"]`. More generally, the driver syntax is: `redis://:password@host:port/database#prefix` - all parameter are optional, hence just `redis:` is a valid driver uri. More infos about drivers in [lib/drivers](https://github.com/dotcloud/hipache/tree/master/lib/drivers). You can omit this entirely to use the local redis on the default port, which is the default.\n * __user__: if starting as root (which you might do if you want to use a privileged port), will drop root privileges as soon as it's bound. Defaults to `www-data`. Note that you MUST specify a user if you start hipache as root. You can specify `user: root` if you don't mind (strongly discouraged!). You can use either user names or ids.\n * __group__: if starting as root, will downgrade group to this. If left empty, will try to downgrade to a group named after the specified `user`. Defaults to `www-data`.\n\n### 3. Spawning\n\nFrom the shell (defaults to using the `config/config.json` file):\n\n    $ hipache\n\nIf you use a privileged port (eg: 80):\n\n    $ sudo hipache\n\nIf you want to use a specific configuration file:\n\n    $ hipache --config path/to/someConfig.json\n\nIf you want to just test a specific configuration file:\n\n    $ hipache --dry --config path/to/someConfig.json\n\n__Managing multiple configuration files:__\n\nThe default configuration file is `config/config.json`. It's possible to have\ndifferent configuration files named `config_<suffix>.json`, where the suffix\nis the value of an environment variable named `SETTINGS_FLAVOR`.\n\nFor instance, here is how to spawn the server with the `config_test.json`\nconfiguration file in order to run the tests.\n\n    $ SETTINGS_FLAVOR=test hipache\n\n\n### 4. Configuring a vhost (redis)\n\nAll vhost configuration is managed through Redis. This makes it possible to\nupdate the configuration dynamically and gracefully while the server is\nrunning, and have that state shared across workers and even across Hipache instances.\n\nIt also makes it simple to write configuration adapters. It would be trivial\nto load a plain text configuration file into Redis (and update it at runtime).\n\nDifferent configuration adapters will follow, but for the moment you have to\nprovision the Redis manually.\n\nLet's take an example, I want to proxify requests to 2 backends for the\nhostname www.dotcloud.com. The 2 backends IP are 192.168.0.42 and 192.168.0.43\nand they serve the HTTP traffic on the port 80.\n\n`redis-cli` is the standard client tool to talk to Redis from the terminal.\n\nHere are the steps I will follow:\n\n1. __Create__ the frontend and associate an identifier\n\n        $ redis-cli rpush frontend:www.dotcloud.com mywebsite\n        (integer) 1\n\nThe frontend identifer is `mywebsite`, it could be anything.\n\n2. __Associate__ the 2 backends\n\n        $ redis-cli rpush frontend:www.dotcloud.com http://192.168.0.42:80\n        (integer) 2\n        $ redis-cli rpush frontend:www.dotcloud.com http://192.168.0.43:80\n        (integer) 3\n\n3. __Review__ the configuration\n\n        $ redis-cli lrange frontend:www.dotcloud.com 0 -1\n        1) \"mywebsite\"\n        2) \"http://192.168.0.42:80\"\n        3) \"http://192.168.0.43:80\"\n\nWhile the server is running, any of these steps can be re-run without messing\nup with the traffic.\n\n### 5. OS integration\n\n__Upstart__\n\nCopy upstart.conf to __/etc/init/hipache.conf__.\n\nThen you can use:\n\n```\nstart hipache\nstop hipache\nrestart hipache\n```\n\nThe configuration file used is `/etc/hipache.json`.\n\nFeatures\n--------\n\n### Load-balancing across multiple backends\n\nAs seen in the example above, multiple backends can be attached to a frontend.\n\nAll requests coming to the frontend are load-balanced across all healthy\nbackends.\n\nThe backend to use for a specific request is determined randomly. Subsequent\nrequests coming from the same client won't necessarily be routed to the same\nbackend (since backend selection is purely random).\n\n### Dead backend detection\n\nIf a backend stops responding, it will be flagged as dead for a\nconfigurable amount of time. The dead backend will be temporarily removed from\nthe load-balancing rotation.\n\n### Multi-process architecture\n\nTo optimize response times and make use of all your available cores, Hipache\nuses the cluster module (included in NodeJS), and spreads the load across\nmultiple NodeJS processes. A master process is in charge of spawning workers\nand monitoring them. When a worker dies, the master spawns a new one.\n\n### Memory monitoring\n\nThe memory footprint of Hipache tends to grow slowly over time, indicating\na probable memory leak. A close examination did not turn up any memory leak\nin Hipache's code itself; but it doesn't prove that there is none. Also,\nwe did not investigate (yet) thoroughly the code of Hipache's external\ndependencies, so the leaks could be creeping there.\n\nWhile we profile Hipache's memory to further reduce its footprint, we\nimplemented a memory monitoring system to make sure that memory use doesn't\ngo out of bounds. Each worker monitors its memory usage. If it crosses\na given threshold, the worker stops accepting new connections, it lets\nthe current requests complete cleanly, and it stops itself; it is then\nreplaced by a new copy by the master process.\n\n### Dynamic configuration\n\nYou can alter the configuration stored in Redis at any time. There is no\nneed to restart Hipache, or to signal it that the configuration has changed:\nHipache will re-query Redis at each request. Worried about performance?\nWe were, too! And we found out that accessing a local Redis is helluva fast.\nSo fast, that it didn't increase measurably the HTTP request latency!\n\n### WebSocket\n\nHipache supports the WebSocket protocol. It doesn't do any fancy handling\non its own and relies entirely on NodeJS and node-http-proxy.\n\n### SSL\n\nHipache supports SSL for \"regular\" requests as well as WebSocket upgrades.\n\n### Custom HTML error pages\n\nWhen something wrong happens (e.g., a backend times out), or when a request\nfor an undefined virtual host comes in, Hipache will display an error page.\nThose error pages can be customized.\n\n### Wildcard domains support\n\nWhen adding virtual hosts in Hipache configuration, you can specify wildcards.\nE.g., instead (or in addition to) www.example.tld, you can insert\n*.example.tld. Hipache will look for an exact match first, and then for a\nwildcard one up to 5 subdomains deep, e.g. foo.bar.baz.qux.quux will attempt to\nmatch itself first, then *.bar.baz.qux.quux, then *.baz.qux.quux, etc.\n\n### Active Health-Check\n\nEven though Hipache support passive health checks, it's also possible to run\nactive health checks. This mechanism requires to run an external program (see third-party softwares below).\n\n\nThird party softwares of interest\n-------------------\n\nHealth-checkers:\n\n * [hipache-hchecker (golang)](https://github.com/samalba/hipache-hchecker)\n * [hipcheck (node.js)](https://github.com/runnable/hipcheck).\n\nA web interface to manage vhosts:\n\n * [airfield](https://github.com/emblica/airfield)\n\n[npm-url]: https://npmjs.org/package/hipache\n[npm-image]: https://badge.fury.io/js/hipache.png\n\n[travis-url]: http://travis-ci.org/hipache/hipache\n[travis-image]: https://secure.travis-ci.org/hipache/hipache.png?branch=master\n\n[coveralls-url]: https://coveralls.io/r/dotcloud/hipache\n[coveralls-image]: https://coveralls.io/repos/dotcloud/hipache/badge.png?branch=master\n\n[depstat-url]: https://david-dm.org/hipache/hipache\n[depstat-image]: https://david-dm.org/hipache/hipache.png\n\n[codeclimate-url]: https://codeclimate.com/github/dotcloud/hipache\n[codeclimate-image]: https://codeclimate.com/github/dotcloud/hipache.png\n\n[waffle-url]: https://waffle.io/hipache/hipache\n[waffle-image]: https://badge.waffle.io/hipache/hipache.png?label=in%20progress&title=Ready\n",
  "readmeFilename": "README.md",
  "_id": "hipache@0.4.0",
  "_shasum": "f8bc2c49e0ed35bdae08a275db51887e74db39c8",
  "_from": "git://github.com/hipache/hipache.git#c32e3d2138590cbdb70a67e696c5f8252f7143dc",
  "_resolved": "git://github.com/hipache/hipache.git#c32e3d2138590cbdb70a67e696c5f8252f7143dc"
}
